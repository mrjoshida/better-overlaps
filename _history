{"entries":[{"timestamp":1745515238950,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":21141,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":214,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1745515806804,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":26,"length1":70,"diffs":[[1,"//% color=\"#03a5fc\" icon=\"\\uf005\"\n//% groups=\"['Sprites','Tilemaps']\" // MODIFIED: Removed 'Walls', 'Regions'. Changed 'Tiles' to 'Tilemaps' for consistency.\n"]]},{"start1":844,"length1":20,"diffs":[[1,"    // REMOVED: RegionEvent enum\n    // REMOVED: WallEvent enum\n    // REMOVED: WallFlag enum\n\n    enum TileFlag { // KEPT: Used by Tile events\n"]]},{"start1":1083,"length1":121,"diffs":[[1,"    type SpriteHandler = (sprite: Sprite, otherSprite: Sprite) => void; // KEPT\n    type TileHandler = (sprite: Sprite) => void; // KEPT\n"]]},{"start1":1221,"length1":34,"diffs":[[1,"    let stateStack: EventState[]; // KEPT: Core state management\n"]]},{"start1":1287,"length1":23,"diffs":[[1,"    // REMOVED: Region class\n    // REMOVED: WallCondition class\n    // REMOVED: Coordinate class\n\n    class EventState { // KEPT: Core state management, but modified\n"]]},{"start1":1542,"length1":0,"diffs":[[1,"        // REMOVED: regionHandlers: RegionHandlerEntry[];\n        // REMOVED: wallHandlers: WallHandlerEntry[];\n"]]},{"start1":1787,"length1":0,"diffs":[[1,"            // REMOVED: this.regionHandlers = [];\n            // REMOVED: this.wallHandlers = [];\n"]]},{"start1":2090,"length1":0,"diffs":[[1,"            // REMOVED: let shouldPruneCurrentState: boolean;\n            // REMOVED: let shouldPruneAllStates: boolean;\n\n"]]},{"start1":2465,"length1":0,"diffs":[[1,"\n                // Sprite-Sprite overlap logic (KEPT)\n"]]},{"start1":2791,"length1":76,"diffs":[[1,"                        data.overlappingSprites.removeElement(otherSprite); // Or removeAt(i)\n"]]},{"start1":3227,"length1":0,"diffs":[[1,"                // Tile overlap logic (KEPT)\n"]]},{"start1":3489,"length1":0,"diffs":[[1,"                            // Get the tile index for the image specified in the handler\n"]]},{"start1":3666,"length1":58,"diffs":[[1,"                            if (targetTileIndex !== -1) { // getImageType returns -1 if image is not in tilemap\n"]]},{"start1":3884,"length1":53,"diffs":[[1,"                                    targetTileIndex, // Pass the target tile index for which the event was registered\n"]]},{"start1":4177,"length1":0,"diffs":[[1,"\n                // REMOVED: Wall processing logic\n                // (The loop `for (const wallState of data.walls)`)\n"]]},{"start1":4310,"length1":0,"diffs":[[1,"\n            // REMOVED: this.doRegionUpdate();\n\n"]]},{"start1":4410,"length1":80,"diffs":[[1,"        getSpriteHandler(event: SpriteEvent, kind: number, otherKind: number) { // KEPT\n"]]},{"start1":4751,"length1":71,"diffs":[[1,"\n        getTileHandler(event: TileEvent, kind: number, image: Image) { // KEPT\n"]]},{"start1":4886,"length1":0,"diffs":[[1,"                // Ensure handler.tile is valid before calling .equals()\n"]]},{"start1":5166,"length1":42,"diffs":[[1,"        // REMOVED: getRegionHandler method\n        // REMOVED: getWallHandler method\n\n        protected pruneTrackedSprites() { // KEPT\n"]]},{"start1":5597,"length1":0,"diffs":[[1,"\n        // REMOVED: doRegionUpdate method\n        // REMOVED: runRegionHandler method\n"]]},{"start1":5691,"length1":31,"diffs":[[1,"    // REMOVED: wallTileStateIsHitting function\n    // REMOVED: wallStateIsHitting function\n\n    class SpriteHandlerEntry { // KEPT\n"]]},{"start1":6017,"length1":29,"diffs":[[1,"    class TileHandlerEntry { // KEPT\n"]]},{"start1":6145,"length1":32,"diffs":[[1,"            public tile: Image, // This is the Image this handler is for\n"]]},{"start1":6279,"length1":28,"diffs":[[1,"    // REMOVED: RegionHandlerEntry class\n    // REMOVED: WallHandlerEntry class\n\n    class SpriteEventData { // KEPT: Modified\n"]]},{"start1":6444,"length1":28,"diffs":[[1,"        tiles: TileState[]; // Stores state by TILE INDEX\n        // REMOVED: regions: RegionState[];\n        // REMOVED: walls: WallState[];\n"]]},{"start1":6702,"length1":0,"diffs":[[1,"            // REMOVED: this.regions = [];\n            // REMOVED: this.walls = [];\n"]]},{"start1":6797,"length1":67,"diffs":[[1,"        getTileEntry(tileIndex: number, createIfMissing = false) { // KEPT: Modified to use tileIndex\n"]]},{"start1":6944,"length1":52,"diffs":[[1,"                if (tile.tileIndex === tileIndex) { // Compare with tileIndex\n"]]},{"start1":7123,"length1":59,"diffs":[[1,"                const newEntry = new TileState(tileIndex); // Store tileIndex\n"]]},{"start1":7330,"length1":0,"diffs":[[1,"\n        // REMOVED: getRegionEntry method\n        // REMOVED: getWallEntry method\n"]]},{"start1":7420,"length1":22,"diffs":[[1,"    class TileState { // KEPT: Modified to use tileIndex\n"]]},{"start1":7499,"length1":58,"diffs":[[1,"        constructor(public tileIndex: number, flag = 0) { // Stores the TILE INDEX (ID)\n"]]},{"start1":7634,"length1":22,"diffs":[[1,"    // REMOVED: RegionState class\n    // REMOVED: WallState class\n    // REMOVED: WallTileState class\n\n    function init() { // KEPT: Core state management\n"]]},{"start1":7965,"length1":81,"diffs":[[1,"        game.addScenePopHandler(() => { // MODIFIED: Corrected from removeScenePushHandler\n            if (stateStack.length > 1) { // Prevent popping the last state if not desired\n"]]},{"start1":8194,"length1":43,"diffs":[[1,"            if (stateStack.length === 0) { // Should not happen if pop is guarded, but as a fallback\n"]]},{"start1":8379,"length1":23,"diffs":[[1,"    function state() { // KEPT: Core state management\n"]]},{"start1":8785,"length1":143,"diffs":[[1,"    export function spriteEvent(kind: number, otherKind: number, event: SpriteEvent, handler: (sprite: Sprite, otherSprite: Sprite) => void) { // KEPT\n"]]},{"start1":9489,"length1":0,"diffs":[[1,"\n"]]},{"start1":9615,"length1":74,"diffs":[[1,"                if (currentState.trackedSprites.indexOf(sprite) === -1) { // Avoid duplicates\n"]]},{"start1":10609,"length1":112,"diffs":[[1,"    export function tileEvent(kind: number, tile: Image, event: TileEvent, handler: (sprite: Sprite) => void) { // KEPT\n"]]},{"start1":10745,"length1":27,"diffs":[[1,"        if (!tile) return; // Guard for invalid tile image\n"]]},{"start1":11076,"length1":0,"diffs":[[1,"        // scene.onOverlapTile is native and efficient. It is called when 'sprite' of 'kind'\n        // overlaps the specific 'tile' Image.\n"]]},{"start1":11434,"length1":0,"diffs":[[1,"            // The 'tile' parameter here is the Image we registered the event for.\n            // We need its index for our internal state management.\n"]]},{"start1":11652,"length1":36,"diffs":[[1,"            if (tileIndex !== -1) { // Make sure the image is actually in the tilemap's palette\n"]]},{"start1":11863,"length1":99,"diffs":[[1,"    // This function now takes tileIndex (ID of the tile type)\n    function updateTileStateAndFireEvents(sprite: Sprite, tileIndex: number, map: tiles.TileMap) { // KEPT & REFINED\n"]]},{"start1":12265,"length1":65,"diffs":[[1,"            if (state().trackedSprites.indexOf(sprite) === -1) { // Avoid duplicates\n"]]},{"start1":12428,"length1":62,"diffs":[[1,"        const tileState = data.getTileEntry(tileIndex, true); // Get/create state for this tileIndex\n"]]},{"start1":12570,"length1":60,"diffs":[[1,"        updateTileState(tileState, sprite, tileIndex, map); // Update flags based on tileIndex\n"]]},{"start1":12716,"length1":0,"diffs":[[1,"        // To call the correct handler, we need the Image that corresponds to this tileIndex\n"]]},{"start1":12874,"length1":42,"diffs":[[1,"        if (!tileImageForHandler) return; // Should not happen if tileIndex is valid\n"]]},{"start1":12960,"length1":38,"diffs":[[1,"        const currentState = state(); // Get current EventState\n"]]},{"start1":14737,"length1":115,"diffs":[[1,"    // This function updates flags in tileState based on matching tileIndexToMatch (ID)\n    function updateTileState(tileState: TileState, sprite: Sprite, tileIndexToMatch: number, map: tiles.TileMap) { // KEPT & REFINED\n"]]},{"start1":15382,"length1":0,"diffs":[[1,"        // Case 1: Sprite's bounding box is within a single tile grid cell\n"]]},{"start1":15495,"length1":0,"diffs":[[1,"            // Check if current cell is within map bounds\n"]]},{"start1":15943,"length1":0,"diffs":[[1,"        // Case 2: Sprite spans multiple tile grid cells\n"]]},{"start1":16045,"length1":56,"diffs":[[1,"        let isSpriteFullyContainedInTargetTiles = true; // Assume true until proven otherwise\n"]]},{"start1":16226,"length1":0,"diffs":[[1,"                // Check if current cell (x,y) is within map bounds\n"]]},{"start1":16381,"length1":95,"diffs":[[1,"                    isSpriteFullyContainedInTargetTiles = false; // Part of sprite is outside map, so not fully contained in target area\n                    continue; // Skip checking this cell\n"]]},{"start1":16805,"length1":0,"diffs":[[1,"                    // If any tile under the sprite's bounding box is NOT the target tile,\n                    // then the sprite is not fully contained in an area of target tiles.\n"]]},{"start1":17295,"length1":0,"diffs":[[1,"                // \"FullyWithin\" (TileEvent.Enters/Exits for a single tile type) is complex for multi-cell sprites.\n                // The original logic for single-cell containment (x0 === x1 && y0 === y1) already sets TileFlag.FullyWithin.\n                // For larger sprites, \"FullyWithin\" a single tile instance is not possible.\n                // The TileFlag.FullyWithin here is primarily for when the sprite fits into one cell of the target type.\n"]]},{"start1":17782,"length1":0,"diffs":[[1,"\n    // REMOVED: runTileEventHandlers (its logic is now integrated into updateTileStateAndFireEvents)\n\n    // REMOVED: wallEvent block function\n    // REMOVED: regionEvent block function\n    // REMOVED: createCoordinate block function\n    // REMOVED: createRegionFromCoordinates block function\n    // REMOVED: createRegionFromLocations block function\n    // REMOVED: simpleWallCondition block function\n    // REMOVED: wallCondition block function\n\n    // --- NEW CUSTOM BLOCK ---\n"]]},{"start1":19441,"length1":0,"diffs":[[1,"        // Determine the range of tile coordinates the sprite could be overlapping\n"]]},{"start1":19922,"length1":53,"diffs":[[1,"                const tileObject = tm.getTile(c, r); // Get the Tile object\n"]]},{"start1":19999,"length1":0,"diffs":[[1,"                // tileSet 0 is often transparent/empty. If you want to check against transparent tiles, remove tileObject.tileSet !== 0\n"]]},{"start1":20206,"length1":130,"diffs":[[1,"                    const tileId = tileObject.tileSet;          // Get its index (ID)\n                    const currentTileImgFromMap = tm.getTileImage(tileId); // Get Image using the tile ID (single argument)\n"]]},{"start1":20509,"length1":0,"diffs":[[1,"                        // AABB overlap check\n"]]}]}]},{"timestamp":1745516341092,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":62,"diffs":[[1,"//% block=\"Sprite Events\"\n//% color=\"#FB8C00\" icon=\"\\uf005\"\n"]]}]}]},{"timestamp":1745517106773,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":62,"length1":0,"diffs":[[1,"//% groups=\"['Sprites','Tilemaps']\"\n"]]}]}]},{"timestamp":1745517196592,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":62,"length1":21,"diffs":[[1,"namespace events {\n"]]},{"start1":5973,"length1":44,"diffs":[[1,"    //% blockId=sprite_event_ext_sprite_event\n"]]},{"start1":6228,"length1":0,"diffs":[[1,"    //% group=\"Sprites\"\n"]]},{"start1":7790,"length1":42,"diffs":[[1,"    //% blockId=sprite_event_ext_tile_event\n"]]},{"start1":8022,"length1":0,"diffs":[[1,"    //% group=\"Tilemaps\"\n"]]},{"start1":13747,"length1":41,"diffs":[[1,"    //% blockId=\"events_is_sprite_overlapping_tile_image\"\n"]]},{"start1":13950,"length1":0,"diffs":[[1,"    //% group=\"Tilemaps\"\n"]]}]}]},{"timestamp":1745517746044,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":62,"length1":26,"diffs":[[1,""]]},{"start1":6228,"length1":25,"diffs":[[1,""]]},{"start1":7996,"length1":25,"diffs":[[1,""]]},{"start1":13900,"length1":25,"diffs":[[1,""]]}]}]},{"timestamp":1745518333902,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":62,"length1":55,"diffs":[[1,"//% groups=\"['Overlaps']\"\nnamespace overlaps {\n"]]},{"start1":750,"length1":98,"diffs":[[1,"    enum TileFlag {\n"]]},{"start1":865,"length1":137,"diffs":[[1,"    type SpriteHandler = (sprite: Sprite, otherSprite: Sprite) => void;\n    type TileHandler = (sprite: Sprite) => void;\n"]]},{"start1":987,"length1":42,"diffs":[[1,"    let stateStack: EventState[];\n"]]},{"start1":1022,"length1":104,"diffs":[[1,"    class EventState {\n"]]},{"start1":1133,"length1":112,"diffs":[[1,""]]},{"start1":1266,"length1":98,"diffs":[[1,""]]},{"start1":1471,"length1":172,"diffs":[[1,""]]},{"start1":1607,"length1":0,"diffs":[[1,"\n"]]},{"start1":1724,"length1":373,"diffs":[[1,"                for (let i = data.overlappingSprites.length - 1; i >= 0; i--) {\n"]]},{"start1":1995,"length1":194,"diffs":[[1,"                        data.overlappingSprites.removeElement(otherSprite);\n"]]},{"start1":2372,"length1":58,"diffs":[[1,""]]},{"start1":2413,"length1":157,"diffs":[[1,"                const tileMap = game.currentScene().tileMap;\n                if (tileMap) {\n"]]},{"start1":2568,"length1":304,"diffs":[[1,"                        if (handler.kind === sprite.kind()) {\n                            const targetTileIndex = tileMap.getImageType(handler.tile);\n                            if (targetTileIndex !== -1) {\n"]]},{"start1":2882,"length1":113,"diffs":[[1,"                                    targetTileIndex,\n                                    tileMap\n"]]},{"start1":3110,"length1":75,"diffs":[[1,""]]},{"start1":3124,"length1":65,"diffs":[[1,""]]},{"start1":3175,"length1":102,"diffs":[[1,"        getSpriteHandler(event: SpriteEvent, kind: number, otherKind: number) {\n"]]},{"start1":3508,"length1":93,"diffs":[[1,"        getTileHandler(event: TileEvent, kind: number, image: Image) {\n"]]},{"start1":3634,"length1":153,"diffs":[[1,"                if (handler.event === event && handler.kind === kind && handler.tile && handler.tile.equals(image))\n"]]},{"start1":3841,"length1":205,"diffs":[[1,"        protected pruneTrackedSprites() {\n"]]},{"start1":4177,"length1":105,"diffs":[[1,""]]},{"start1":4184,"length1":160,"diffs":[[1,"    class SpriteHandlerEntry {\n"]]},{"start1":4409,"length1":51,"diffs":[[1,"    class TileHandlerEntry {\n"]]},{"start1":4529,"length1":77,"diffs":[[1,"            public tile: Image,\n"]]},{"start1":4622,"length1":165,"diffs":[[1,"    class SpriteEventData {\n"]]},{"start1":4688,"length1":142,"diffs":[[1,"        tiles: TileState[];\n"]]},{"start1":4832,"length1":84,"diffs":[[1,""]]},{"start1":4843,"length1":297,"diffs":[[1,"        getTileEntry(tileIndex: number, createIfMissing = false) {\n            for (const tile of this.tiles) {\n                if (tile.tileIndex === tileIndex) {\n                    return tile;\n"]]},{"start1":5072,"length1":0,"diffs":[[1,"\n"]]},{"start1":5108,"length1":136,"diffs":[[1,"                const newEntry = new TileState(tileIndex);\n                this.tiles.push(newEntry)\n"]]},{"start1":5296,"length1":101,"diffs":[[1,""]]},{"start1":5303,"length1":86,"diffs":[[1,"    class TileState {\n"]]},{"start1":5347,"length1":100,"diffs":[[1,"        constructor(public tileIndex: number, flag = 0) {\n"]]},{"start1":5452,"length1":177,"diffs":[[1,"    function init() {\n"]]},{"start1":5649,"length1":102,"diffs":[[1,"        game.addScenePopHandler(() => {\n"]]},{"start1":5778,"length1":148,"diffs":[[1,"            if (stateStack.length === 0) {\n                stateStack.push(new EventState());\n"]]},{"start1":5905,"length1":45,"diffs":[[1,"    function state() {\n"]]},{"start1":6001,"length1":71,"diffs":[[1,"    //% blockId=sprite_overlap_sprite_event\n"]]},{"start1":6130,"length1":61,"diffs":[[1,"    //% draggableParameters=\"reporter\"\n"]]},{"start1":6254,"length1":190,"diffs":[[1,"    //% group=\"Overlaps\"\n    export function spriteEvent(kind: number, otherKind: number, event: SpriteEvent, handler: (sprite: Sprite, otherSprite: Sprite) => void) {\n"]]},{"start1":7568,"length1":110,"diffs":[[1,"                const handler = currentState.getSpriteHandler(SpriteEvent.StartOverlapping, kind, otherKind)\n"]]},{"start1":7817,"length1":69,"diffs":[[1,"    //% blockId=sprite_overlap_tile_event\n"]]},{"start1":7918,"length1":61,"diffs":[[1,"    //% draggableParameters=\"reporter\"\n"]]},{"start1":8047,"length1":160,"diffs":[[1,"    //% group=\"Overlaps\"\n    export function tileEvent(kind: number, tile: Image, event: TileEvent, handler: (sprite: Sprite) => void) {\n"]]},{"start1":8717,"length1":474,"diffs":[[1,"            const tileIndex = tileMapInstance.getImageType(tile);\n\n            if (tileIndex !== -1) {\n                updateTileStateAndFireEvents(sprite, tileIndex, tileMapInstance);\n            }\n"]]},{"start1":8935,"length1":138,"diffs":[[1,"    function updateTileStateAndFireEvents(sprite: Sprite, tileIndex: number, map: tiles.TileMap) {\n"]]},{"start1":9461,"length1":1,"diffs":[[1,""]]},{"start1":9613,"length1":313,"diffs":[[1,"        const tileImageForHandler = map.getTileImage(tileIndex);\n        if (!tileImageForHandler) return;\n\n        const currentState = state();\n\n"]]},{"start1":9867,"length1":85,"diffs":[[1,"                const handler = currentState.getTileHandler(TileEvent.StartOverlapping, sprite.kind(), tileImageForHandler);\n                if (handler) handler.handler(sprite);\n"]]},{"start1":10060,"length1":0,"diffs":[[1,"        } else if (oldFlags & TileFlag.Overlapping) {\n            const handler = currentState.getTileHandler(TileEvent.StopOverlapping, sprite.kind(), tileImageForHandler);\n            if (handler) handler.handler(sprite);\n"]]},{"start1":10294,"length1":142,"diffs":[[1,""]]},{"start1":10402,"length1":75,"diffs":[[1,"                const handler = currentState.getTileHandler(TileEvent.Enters, sprite.kind(), tileImageForHandler);\n                if (handler) handler.handler(sprite);\n"]]},{"start1":10585,"length1":0,"diffs":[[1,"        } else if (oldFlags & TileFlag.FullyWithin) {\n            const handler = currentState.getTileHandler(TileEvent.Exits, sprite.kind(), tileImageForHandler);\n            if (handler) handler.handler(sprite);\n"]]},{"start1":10809,"length1":132,"diffs":[[1,""]]},{"start1":10915,"length1":79,"diffs":[[1,"                const handler = currentState.getTileHandler(TileEvent.EntersArea, sprite.kind(), tileImageForHandler);\n                if (handler) handler.handler(sprite);\n"]]},{"start1":11102,"length1":0,"diffs":[[1,"        } else if (oldFlags & TileFlag.WithinArea) {\n            const handler = currentState.getTileHandler(TileEvent.ExitsArea, sprite.kind(), tileImageForHandler);\n            if (handler) handler.handler(sprite);\n"]]},{"start1":11329,"length1":135,"diffs":[[1,""]]},{"start1":11330,"length1":1,"diffs":[[1,""]]},{"start1":11472,"length1":173,"diffs":[[1,"    function updateTileState(tileState: TileState, sprite: Sprite, tileIndexToMatch: number, map: tiles.TileMap) {\n"]]},{"start1":12049,"length1":161,"diffs":[[1,"            if (x0 >= 0 && x0 < map.areaWidth() && y0 >= 0 && y0 < map.areaHeight()) {\n"]]},{"start1":12408,"length1":60,"diffs":[[1,"            return;\n"]]},{"start1":12439,"length1":331,"diffs":[[1,"        let isOverlappingTargetTile = false;\n        let isSpriteFullyContainedInTargetTiles = true;\n"]]},{"start1":12541,"length1":85,"diffs":[[1,""]]},{"start1":12627,"length1":196,"diffs":[[1,"                if (x < 0 || x >= map.areaWidth() || y < 0 || y >= map.areaHeight()) {\n                    isSpriteFullyContainedInTargetTiles = false;\n"]]},{"start1":12827,"length1":94,"diffs":[[1,"\n                const currentTile = map.getTile(x, y);\n"]]},{"start1":12962,"length1":99,"diffs":[[1,"                    isOverlappingTargetTile = true;\n"]]},{"start1":13039,"length1":89,"diffs":[[1,"                    isSpriteFullyContainedInTargetTiles = false;\n"]]},{"start1":13147,"length1":123,"diffs":[[1,"        if (isOverlappingTargetTile) {\n            tileState.flag |= TileFlag.Overlapping;\n            if (isSpriteFullyContainedInTargetTiles) {\n                tileState.flag |= TileFlag.WithinArea;\n            }\n"]]},{"start1":13372,"length1":175,"diffs":[[1,""]]},{"start1":13379,"length1":486,"diffs":[[1,"    /**\n     * Checks if a sprite is currently overlapping any tile with the specified image.\n     * This is a synchronous check performed at the moment the block is called.\n     * @param sprite The sprite to check.\n     * @param tileImage The image of the tile to check for overlap with.\n     * @returns true if the sprite is overlapping a tile with the given image, false otherwise.\n     */\n    //% blockId=sprite_overlap_tile_bool\n    //% block=\"$sprite is currently overlapping tile image $tileImage\"\n    //% sprite.defl=mySprite\n    //% tileImage.shadow=tileset_tile_picker\n    //% weight=95\n    //% group=\"Overlaps\"\n    export function isSpriteOverlappingTileImage(sprite: Sprite, tileImage: Image): boolean {\n        if (!sprite || !tileImage) {\n            return false;\n        }\n"]]},{"start1":14169,"length1":212,"diffs":[[1,"        const scene = game.currentScene();\n        const tm = scene.tileMap;\n\n        if (!tm || tm.areaWidth() === 0 || tm.areaHeight() === 0) {\n            return false;\n        }\n\n        const scale = 1 << tm.scale;\n\n        const spriteL = sprite.left;\n        const spriteR = sprite.right;\n        const spriteT = sprite.top;\n        const spriteB = sprite.bottom;\n\n        const minCol = Math.max(0, Math.floor(spriteL / scale));\n        const maxCol = Math.min(tm.areaWidth() - 1, Math.floor(spriteR / scale));\n        const minRow = Math.max(0, Math.floor(spriteT / scale));\n        const maxRow = Math.min(tm.areaHeight() - 1, Math.floor(spriteB / scale));\n\n        for (let r = minRow; r <= maxRow; r++) {\n            for (let c = minCol; c <= maxCol; c++) {\n                const tileObject = tm.getTile(c, r);\n\n                if (tileObject && tileObject.tileSet !== undefined) {\n                    const tileId = tileObject.tileSet;\n                    const currentTileImgFromMap = tm.getTileImage(tileId);\n\n                    if (currentTileImgFromMap && currentTileImgFromMap.equals(tileImage)) {\n                        const tileLeft = c * scale;\n                        const tileTop = r * scale;\n                        const tileRight = tileLeft + scale;\n                        const tileBottom = tileTop + scale;\n\n                        if (spriteL < tileRight &&\n                            spriteR > tileLeft &&\n                            spriteT < tileBottom &&\n                            spriteB > tileTop) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n"]]}]}]},{"timestamp":1745518943743,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":62,"length1":212,"diffs":[[1,"//% groups=\"['Sprites','Tilemaps']\"\nnamespace events {\n"]]},{"start1":17777,"length1":2654,"diffs":[[1,""]]}]}]},{"timestamp":1745519003744,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":62,"length1":47,"diffs":[[1,"//% groups=\"['Sprites','Tilemaps']\" // MODIFIED: Removed Walls, Regions; Original 'Tiles' changed to 'Tilemaps' for clarity\nnamespace events { // Original namespace name 'events' is kept for internal consistency\n"]]},{"start1":915,"length1":20,"diffs":[[1,"    // REMOVED Enums: RegionEvent, WallEvent, WallFlag\n\n    enum TileFlag { // Kept from original\n"]]},{"start1":1108,"length1":121,"diffs":[[1,"    type SpriteHandler = (sprite: Sprite, otherSprite: Sprite) => void; // Kept\n    type TileHandler = (sprite: Sprite) => void; // Kept\n"]]},{"start1":1246,"length1":34,"diffs":[[1,"    let stateStack: EventState[]; // Kept\n"]]},{"start1":1289,"length1":23,"diffs":[[1,"    // REMOVED Classes: Region, WallCondition, Coordinate\n\n    class EventState { // Kept, but modified\n"]]},{"start1":1481,"length1":0,"diffs":[[1,"        // REMOVED: regionHandlers: RegionHandlerEntry[];\n        // REMOVED: wallHandlers: WallHandlerEntry[];\n"]]},{"start1":1726,"length1":0,"diffs":[[1,"            // REMOVED: this.regionHandlers = [];\n            // REMOVED: this.wallHandlers = [];\n"]]},{"start1":2029,"length1":0,"diffs":[[1,"            // REMOVED: let shouldPruneCurrentState: boolean; from original wall logic\n            // REMOVED: let shouldPruneAllStates: boolean; from original wall logic\n\n"]]},{"start1":2337,"length1":1,"diffs":[[1,""]]},{"start1":2453,"length1":80,"diffs":[[1,"                // Sprite-Sprite overlap logic (Kept from original)\n                // Iterate backwards if removing elements, or filter. Original used removeElement.\n                // For simplicity and closer match to original's intent (though removeElement in loop can be tricky):\n                let i = 0;\n                while (i < data.overlappingSprites.length) {\n"]]},{"start1":3017,"length1":76,"diffs":[[1,"                        data.overlappingSprites.removeElement(otherSprite); // Original method\n                        // If element removed, do not increment i, so next element is at current i\n"]]},{"start1":3512,"length1":0,"diffs":[[1,"                    } else {\n                        i++;\n"]]},{"start1":3611,"length1":92,"diffs":[[1,"                // Tile overlap logic (Kept from original)\n                const tileMapRef = game.currentScene().tileMap;\n                if (tileMapRef) {\n"]]},{"start1":3831,"length1":208,"diffs":[[1,"                        if (handler.kind === sprite.kind() && handler.tile) { // Ensure handler.tile exists\n                            const tileIndex = tileMapRef.getImageType(handler.tile); // Get TILE INDEX from Image\n                            if (tileIndex !== -1) { // -1 if image not in palette\n"]]},{"start1":4241,"length1":97,"diffs":[[1,"                                    tileIndex, // Pass TILE INDEX\n                                    tileMapRef\n"]]},{"start1":4485,"length1":0,"diffs":[[1,"                // REMOVED: Wall processing logic from original's update()\n"]]},{"start1":4574,"length1":0,"diffs":[[1,"\n            // REMOVED: this.doRegionUpdate(); (from original)\n\n"]]},{"start1":4690,"length1":80,"diffs":[[1,"        getSpriteHandler(event: SpriteEvent, kind: number, otherKind: number) { // Kept from original\n"]]},{"start1":5045,"length1":71,"diffs":[[1,"        getTileHandler(event: TileEvent, kind: number, image: Image) { // Kept from original\n"]]},{"start1":5193,"length1":116,"diffs":[[1,"                if (handler.event === event && handler.kind === kind && handler.tile && handler.tile.equals(image)) // Added null check for handler.tile\n"]]},{"start1":5437,"length1":42,"diffs":[[1,"        // REMOVED: getRegionHandler (from original)\n        // REMOVED: getWallHandler (from original)\n\n        protected pruneTrackedSprites() { // Kept from original, iterate backwards for safe removal\n"]]},{"start1":5936,"length1":0,"diffs":[[1,"\n        // REMOVED: doRegionUpdate (from original)\n        // REMOVED: runRegionHandler (from original)\n"]]},{"start1":6048,"length1":31,"diffs":[[1,"    // REMOVED: wallTileStateIsHitting (from original)\n    // REMOVED: wallStateIsHitting (from original)\n\n    class SpriteHandlerEntry { // Kept from original\n"]]},{"start1":6402,"length1":29,"diffs":[[1,"    class TileHandlerEntry { // Kept from original\n"]]},{"start1":6544,"length1":32,"diffs":[[1,"            public tile: Image, // This is the target Image for this handler\n"]]},{"start1":6682,"length1":28,"diffs":[[1,"    // REMOVED: RegionHandlerEntry (from original)\n    // REMOVED: WallHandlerEntry (from original)\n\n    class SpriteEventData { // Kept from original, but modified\n"]]},{"start1":6885,"length1":28,"diffs":[[1,"        tiles: TileState[]; // Stores state by TILE INDEX\n        // REMOVED: regions: RegionState[];\n        // REMOVED: walls: WallState[];\n"]]},{"start1":7143,"length1":0,"diffs":[[1,"            // REMOVED: this.regions = [];\n            // REMOVED: this.walls = [];\n"]]},{"start1":7238,"length1":197,"diffs":[[1,"        getTileEntry(tileIndex: number, createIfMissing = false) { // 'tileIndex' is the ID\n            for (const ts of this.tiles) { // Renamed loop var to avoid conflict\n                if (ts.tileIndex === tileIndex) { // Compare with renamed tileIndex property\n                    return ts;\n"]]},{"start1":7567,"length1":1,"diffs":[[1,""]]},{"start1":7602,"length1":101,"diffs":[[1,"                const newEntry = new TileState(tileIndex); // Use renamed tileIndex property\n                this.tiles.push(newEntry);\n"]]},{"start1":7825,"length1":0,"diffs":[[1,"\n        // REMOVED: getRegionEntry (from original)\n        // REMOVED: getWallEntry (from original)\n"]]},{"start1":7933,"length1":22,"diffs":[[1,"    class TileState { // MODIFIED: 'tile' property renamed to 'tileIndex' for clarity\n"]]},{"start1":8041,"length1":58,"diffs":[[1,"        constructor(public tileIndex: number, flag = 0) { // 'tileIndex' stores the TILE INDEX (ID)\n"]]},{"start1":8188,"length1":22,"diffs":[[1,"    // REMOVED: RegionState (from original)\n    // REMOVED: WallState (from original)\n    // REMOVED: WallTileState (from original)\n\n    function init() { // Kept from original\n"]]},{"start1":8540,"length1":40,"diffs":[[1,"        game.addScenePopHandler(() => { // MODIFIED: Corrected from original's removeScenePushHandler\n"]]},{"start1":8731,"length1":94,"diffs":[[1,"            if (!stateStack.length) {\n                stateStack.push(new EventState()); // Re-initialize if stack became empty (original behavior)\n"]]},{"start1":8912,"length1":23,"diffs":[[1,"    function state() { // Kept from original\n"]]},{"start1":9030,"length1":44,"diffs":[[1,"    //% blockId=sprite_event_ext_sprite_event // Kept original blockId\n"]]},{"start1":9186,"length1":39,"diffs":[[1,"    //% draggableParameters=\"reporter\" // KEPT from original\n"]]},{"start1":9332,"length1":168,"diffs":[[1,"    //% group=\"Sprites\" \n    export function spriteEvent(kind: number, otherKind: number, event: SpriteEvent, handler: (sprite: Sprite, otherSprite: Sprite) => void) { // Kept from original\n"]]},{"start1":10668,"length1":109,"diffs":[[1,"                const handler = currentState.getSpriteHandler(SpriteEvent.StartOverlapping, kind, otherKind);\n"]]},{"start1":10918,"length1":42,"diffs":[[1,"    //% blockId=sprite_event_ext_tile_event // Kept original blockId\n"]]},{"start1":11046,"length1":39,"diffs":[[1,"    //% draggableParameters=\"reporter\" // KEPT from original\n"]]},{"start1":11197,"length1":137,"diffs":[[1,"    //% group=\"Tilemaps\" \n    export function tileEvent(kind: number, tile: Image, event: TileEvent, handler: (sprite: Sprite) => void) { // Kept from original\n"]]},{"start1":11890,"length1":199,"diffs":[[1,"            // 'location.tileSet' is the index of the actual tile instance that was overlapped.\n            // We need to ensure this event triggers our logic for the *specific image* 'tile'\n            // that this handler was registered for. scene.onOverlapTile(kind, tile, ...) already does this matching.\n            // So, location.tileSet will be the index of an instance of 'tile'.\n            updateTileStateAndFireEvents(sprite, location.tileSet, tileMapInstance);\n"]]},{"start1":12383,"length1":99,"diffs":[[1,"    function updateTileStateAndFireEvents(sprite: Sprite, tileIndex: number, map: tiles.TileMap) { // Kept from original, tileIndex is ID\n"]]},{"start1":12948,"length1":0,"diffs":[[1,"\n"]]},{"start1":13101,"length1":147,"diffs":[[1,"        // Call runTileEventHandlers for each relevant event type\n        // This simplified dispatch was in original, restoring it.\n        // Original called runTileEventHandlers without checking flags first inside this func.\n        // The runTileEventHandlers itself will check based on event type and flags.\n"]]},{"start1":13521,"length1":179,"diffs":[[1,"                runTileEventHandlers(sprite, TileEvent.StartOverlapping, tileIndex);\n"]]},{"start1":13620,"length1":224,"diffs":[[1,""]]},{"start1":13630,"length1":0,"diffs":[[1,"        else if (oldFlags & TileFlag.Overlapping) {\n            runTileEventHandlers(sprite, TileEvent.StopOverlapping, tileIndex);\n        }\n"]]},{"start1":13880,"length1":169,"diffs":[[1,"                runTileEventHandlers(sprite, TileEvent.Enters, tileIndex);\n"]]},{"start1":13969,"length1":214,"diffs":[[1,""]]},{"start1":13979,"length1":0,"diffs":[[1,"        else if (oldFlags & TileFlag.FullyWithin) {\n            runTileEventHandlers(sprite, TileEvent.Exits, tileIndex);\n        }\n"]]},{"start1":14217,"length1":173,"diffs":[[1,"                runTileEventHandlers(sprite, TileEvent.EntersArea, tileIndex);\n"]]},{"start1":14310,"length1":217,"diffs":[[1,""]]},{"start1":14320,"length1":0,"diffs":[[1,"        else if (oldFlags & TileFlag.WithinArea) {\n            runTileEventHandlers(sprite, TileEvent.ExitsArea, tileIndex);\n        }\n"]]},{"start1":14456,"length1":0,"diffs":[[1,"\n"]]},{"start1":14599,"length1":115,"diffs":[[1,"    function updateTileState(tileState: TileState, sprite: Sprite, tileIndexToMatch: number, map: tiles.TileMap): TileState { // Kept original signature (returns TileState)\n"]]},{"start1":15234,"length1":87,"diffs":[[1,"            if (x0 >= 0 && x0 < map.areaWidth() && y0 >= 0 && y0 < map.areaHeight()) { // Bounds check\n                // Original used map.getTileIndex(x0, y0)\n"]]},{"start1":15667,"length1":20,"diffs":[[1,"            return tileState; // Original returns tileState\n"]]},{"start1":15738,"length1":101,"diffs":[[1,"        // Original logic for multi-cell overlap:\n        // It sets Overlapping if any matching tile is found.\n        // It then *returns early* if a non-matching tile is found *after* an overlapping one was already found.\n        // This implies WithinArea should only be true if ALL tiles under the sprite are the target tile.\n"]]},{"start1":16070,"length1":0,"diffs":[[1,"        let allTilesMatch = true; // Assume all tiles under sprite will match target\n"]]},{"start1":16241,"length1":152,"diffs":[[1,"                if (x < 0 || x >= map.areaWidth() || y < 0 || y >= map.areaHeight()) { // Bounds check\n                    allTilesMatch = false; // Part of sprite is off-map, so not all matching\n"]]},{"start1":16485,"length1":56,"diffs":[[1,"                const currentTile = map.getTile(x, y); // Original used map.getTileIndex(x,y)\n"]]},{"start1":16658,"length1":52,"diffs":[[1,"                    tileState.flag |= TileFlag.Overlapping; // Set overlapping if any part matches\n"]]},{"start1":16782,"length1":65,"diffs":[[1,"                    allTilesMatch = false; // Found a non-matching tile under the sprite\n"]]},{"start1":16914,"length1":215,"diffs":[[1,"        if ((tileState.flag & TileFlag.Overlapping) && allTilesMatch) {\n            tileState.flag |= TileFlag.WithinArea;\n"]]},{"start1":17047,"length1":0,"diffs":[[1,"        // Note: TileFlag.FullyWithin is only set if sprite fits in a single cell of the target type (handled above).\n\n        return tileState; // Original returns tileState\n"]]},{"start1":17229,"length1":0,"diffs":[[1,"    // Kept runTileEventHandlers from original structure.\n    // This function dispatches the event based on what's passed in.\n    // In the original, updateTileStateAndFireEvents calls this multiple times.\n    function runTileEventHandlers(sprite: Sprite, event: TileEvent, tileIndex: number) {\n        const tileMap = game.currentScene().tileMap;\n        if (!tileMap) return;\n        const image = tileMap.getTileImage(tileIndex); // Get image from index\n        if (!image) return;\n\n        const handler = state().getTileHandler(\n            event,\n            sprite.kind(),\n            image // Use the actual image for handler lookup\n        );\n        if (handler) handler.handler(sprite);\n    }\n\n    // REMOVED: All Wall and Region block functions and their helpers from original\n\n"]]},{"start1":18028,"length1":0,"diffs":[[1,"     * ADDED BLOCK\n"]]},{"start1":18432,"length1":41,"diffs":[[1,"    //% blockId=\"better_overlaps_is_sprite_overlapping_tile_image\" // Using a new unique blockId\n"]]},{"start1":18674,"length1":0,"diffs":[[1,"    //% group=\"Tilemaps\" \n"]]},{"start1":18718,"length1":25,"diffs":[[1,""]]}]}]},{"timestamp":1745521348105,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":13884,"length1":28,"diffs":[[1,"    //% sprite.defl=mySprite\n"]]}]}]},{"timestamp":1745521386807,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":13884,"length1":0,"diffs":[[1,"    //% sprite.defl=mySprit\n"]]}]}]},{"timestamp":1745521501561,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":6236,"length1":0,"diffs":[[1,"    //% weight=90\n"]]},{"start1":8028,"length1":0,"diffs":[[1,"    //% weight=100\n"]]},{"start1":13884,"length1":65,"diffs":[[1,""]]},{"start1":13929,"length1":0,"diffs":[[1,"    //% weight=95\n"]]}]}]},{"timestamp":1745522048604,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":84,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":214,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1745515238949,"editorVersion":"2.0.53","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"better overlaps\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1745517101581,"editorVersion":"2.0.53","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"//% block=\"Better Overlaps\"\n//% color=\"#FB8C00\" icon=\"\\uf259\"\n//% groups=\"['Sprites','Tilemaps']\"\nnamespace events {\n    export const SPRITE_DATA_KEY = \"@$_events_sprite_data\";\n\n    export enum SpriteEvent {\n        //% block=\"starts overlapping\"\n        StartOverlapping,\n        //% block=\"stops overlapping\"\n        StopOverlapping\n    }\n\n    export enum TileEvent {\n        //% block=\"starts overlapping\"\n        StartOverlapping,\n        //% block=\"stops overlapping\"\n        StopOverlapping,\n        //% block=\"fully within\"\n        Enters,\n        //% block=\"no longer fully within\"\n        Exits,\n        //% block=\"fully within area covered by\"\n        EntersArea,\n        //% block=\"no longer fully within area covered by\"\n        ExitsArea\n    }\n\n    enum TileFlag {\n        Overlapping = 1 << 0,\n        FullyWithin = 1 << 1,\n        WithinArea = 1 << 2\n    }\n\n    type SpriteHandler = (sprite: Sprite, otherSprite: Sprite) => void;\n    type TileHandler = (sprite: Sprite) => void;\n\n    let stateStack: EventState[];\n\n    class EventState {\n        spriteHandlers: SpriteHandlerEntry[];\n        tileHandlers: TileHandlerEntry[];\n        trackedSprites: Sprite[];\n\n        constructor() {\n            this.spriteHandlers = [];\n            this.tileHandlers = [];\n            this.trackedSprites = [];\n\n            game.eventContext().registerFrameHandler(scene.PHYSICS_PRIORITY + 1, () => {\n                this.update();\n            });\n        }\n\n        update() {\n            for (const sprite of this.trackedSprites) {\n                if (!sprite || sprite.flags & sprites.Flag.Destroyed) continue;\n\n                const data = sprite.data[SPRITE_DATA_KEY] as SpriteEventData;\n                if (!data) continue;\n\n                for (let i = data.overlappingSprites.length - 1; i >= 0; i--) {\n                    const otherSprite = data.overlappingSprites[i];\n                    if (!otherSprite || otherSprite.flags & sprites.Flag.Destroyed || !sprite.overlapsWith(otherSprite)) {\n                        data.overlappingSprites.removeElement(otherSprite);\n                        if (!otherSprite || otherSprite.flags & sprites.Flag.Destroyed) continue;\n\n                        const handler = this.getSpriteHandler(SpriteEvent.StopOverlapping, sprite.kind(), otherSprite.kind());\n                        if (handler) handler.handler(sprite, otherSprite);\n                    }\n                }\n\n                const tileMap = game.currentScene().tileMap;\n                if (tileMap) {\n                    for (const handler of this.tileHandlers) {\n                        if (handler.kind === sprite.kind()) {\n                            const targetTileIndex = tileMap.getImageType(handler.tile);\n                            if (targetTileIndex !== -1) {\n                                updateTileStateAndFireEvents(\n                                    sprite,\n                                    targetTileIndex,\n                                    tileMap\n                                );\n                            }\n                        }\n                    }\n                }\n            }\n            this.pruneTrackedSprites();\n        }\n\n        getSpriteHandler(event: SpriteEvent, kind: number, otherKind: number) {\n            for (const handler of this.spriteHandlers) {\n                if (handler.event === event && handler.kind === kind && handler.otherKind === otherKind)\n                    return handler;\n            }\n            return undefined;\n        }\n\n        getTileHandler(event: TileEvent, kind: number, image: Image) {\n            for (const handler of this.tileHandlers) {\n                if (handler.event === event && handler.kind === kind && handler.tile && handler.tile.equals(image))\n                    return handler;\n            }\n            return undefined;\n        }\n\n        protected pruneTrackedSprites() {\n            for (let i = this.trackedSprites.length - 1; i >= 0; i--) {\n                const sprite = this.trackedSprites[i];\n                if (!sprite || sprite.flags & sprites.Flag.Destroyed) {\n                    this.trackedSprites.removeAt(i);\n                }\n            }\n        }\n    }\n\n    class SpriteHandlerEntry {\n        constructor(\n            public event: SpriteEvent,\n            public kind: number,\n            public otherKind: number,\n            public handler: SpriteHandler\n        ) { }\n    }\n\n    class TileHandlerEntry {\n        constructor(\n            public event: TileEvent,\n            public kind: number,\n            public tile: Image,\n            public handler: TileHandler\n        ) { }\n    }\n\n    class SpriteEventData {\n        overlappingSprites: Sprite[];\n        tiles: TileState[];\n\n        constructor(public owner: Sprite) {\n            this.overlappingSprites = [];\n            this.tiles = [];\n        }\n\n        getTileEntry(tileIndex: number, createIfMissing = false) {\n            for (const tile of this.tiles) {\n                if (tile.tileIndex === tileIndex) {\n                    return tile;\n                }\n            }\n\n            if (createIfMissing) {\n                const newEntry = new TileState(tileIndex);\n                this.tiles.push(newEntry)\n                return newEntry;\n            }\n            return undefined;\n        }\n    }\n\n    class TileState {\n        flag: number;\n        constructor(public tileIndex: number, flag = 0) {\n            this.flag = flag;\n        }\n    }\n\n    function init() {\n        if (stateStack) return;\n        stateStack = [new EventState()];\n\n        game.addScenePushHandler(() => {\n            stateStack.push(new EventState());\n        });\n\n        game.addScenePopHandler(() => {\n            if (stateStack.length > 1) {\n                stateStack.pop();\n            }\n            if (stateStack.length === 0) {\n                stateStack.push(new EventState());\n            }\n        });\n    }\n\n    function state() {\n        init();\n        return stateStack[stateStack.length - 1];\n    }\n\n    //% blockId=sprite_event_ext_sprite_event\n    //% block=\"on $sprite of kind $kind $event with $otherSprite of kind $otherKind\"\n    //% kind.shadow=spritekind\n    //% otherKind.shadow=spritekind\n    //% weight=90\n    //% group=\"Sprites\"\n    export function spriteEvent(kind: number, otherKind: number, event: SpriteEvent, handler: (sprite: Sprite, otherSprite: Sprite) => void) {\n        init();\n\n        const existing = state().getSpriteHandler(event, kind, otherKind);\n        if (existing) {\n            existing.handler = handler;\n            return;\n        }\n\n        state().spriteHandlers.push(\n            new SpriteHandlerEntry(event, kind, otherKind, handler)\n        );\n\n        sprites.onOverlap(kind, otherKind, (sprite, otherSprite) => {\n            const currentState = state();\n            if (!sprite || !otherSprite || sprite.flags & sprites.Flag.Destroyed || otherSprite.flags & sprites.Flag.Destroyed) return;\n\n            if (!sprite.data[SPRITE_DATA_KEY]) {\n                sprite.data[SPRITE_DATA_KEY] = new SpriteEventData(sprite);\n                if (currentState.trackedSprites.indexOf(sprite) === -1) {\n                    currentState.trackedSprites.push(sprite);\n                }\n            }\n\n            const data: SpriteEventData = sprite.data[SPRITE_DATA_KEY];\n            if (!data) return;\n            const isOverlappingAlready = data.overlappingSprites.indexOf(otherSprite) !== -1;\n\n            if (!isOverlappingAlready) {\n                data.overlappingSprites.push(otherSprite);\n\n                const handler = currentState.getSpriteHandler(SpriteEvent.StartOverlapping, kind, otherKind)\n                if (handler) {\n                    handler.handler(sprite, otherSprite);\n                }\n            }\n        });\n    }\n\n    //% blockId=sprite_event_ext_tile_event\n    //% block=\"on $sprite of kind $kind $event tile $tile\"\n    //% kind.shadow=spritekind\n    //% tile.shadow=tileset_tile_picker\n    //% weight=100\n    //% group=\"Tilemaps\"\n    export function tileEvent(kind: number, tile: Image, event: TileEvent, handler: (sprite: Sprite) => void) {\n        init();\n        if (!tile) return;\n\n        const existing = state().getTileHandler(event, kind, tile);\n        if (existing) {\n            existing.handler = handler;\n            return;\n        }\n\n        state().tileHandlers.push(\n            new TileHandlerEntry(event, kind, tile, handler)\n        );\n\n        scene.onOverlapTile(kind, tile, (sprite, location) => {\n            if (!sprite || !location) return;\n            const tileMapInstance = game.currentScene().tileMap;\n            if (!tileMapInstance) return;\n\n            const tileIndex = tileMapInstance.getImageType(tile);\n\n            if (tileIndex !== -1) {\n                updateTileStateAndFireEvents(sprite, tileIndex, tileMapInstance);\n            }\n        });\n    }\n\n    function updateTileStateAndFireEvents(sprite: Sprite, tileIndex: number, map: tiles.TileMap) {\n        if (!sprite || !map) return;\n        let data: SpriteEventData = sprite.data[SPRITE_DATA_KEY];\n\n        if (!data) {\n            data = new SpriteEventData(sprite);\n            sprite.data[SPRITE_DATA_KEY] = data;\n            if (state().trackedSprites.indexOf(sprite) === -1) {\n                state().trackedSprites.push(sprite);\n            }\n        }\n\n        const tileState = data.getTileEntry(tileIndex, true);\n        const oldFlags = tileState.flag;\n        updateTileState(tileState, sprite, tileIndex, map);\n\n        if (oldFlags === tileState.flag) return;\n\n        const tileImageForHandler = map.getTileImage(tileIndex);\n        if (!tileImageForHandler) return;\n\n        const currentState = state();\n\n        if (tileState.flag & TileFlag.Overlapping) {\n            if (!(oldFlags & TileFlag.Overlapping)) {\n                const handler = currentState.getTileHandler(TileEvent.StartOverlapping, sprite.kind(), tileImageForHandler);\n                if (handler) handler.handler(sprite);\n            }\n        } else if (oldFlags & TileFlag.Overlapping) {\n            const handler = currentState.getTileHandler(TileEvent.StopOverlapping, sprite.kind(), tileImageForHandler);\n            if (handler) handler.handler(sprite);\n        }\n\n        if (tileState.flag & TileFlag.FullyWithin) {\n            if (!(oldFlags & TileFlag.FullyWithin)) {\n                const handler = currentState.getTileHandler(TileEvent.Enters, sprite.kind(), tileImageForHandler);\n                if (handler) handler.handler(sprite);\n            }\n        } else if (oldFlags & TileFlag.FullyWithin) {\n            const handler = currentState.getTileHandler(TileEvent.Exits, sprite.kind(), tileImageForHandler);\n            if (handler) handler.handler(sprite);\n        }\n\n        if (tileState.flag & TileFlag.WithinArea) {\n            if (!(oldFlags & TileFlag.WithinArea)) {\n                const handler = currentState.getTileHandler(TileEvent.EntersArea, sprite.kind(), tileImageForHandler);\n                if (handler) handler.handler(sprite);\n            }\n        } else if (oldFlags & TileFlag.WithinArea) {\n            const handler = currentState.getTileHandler(TileEvent.ExitsArea, sprite.kind(), tileImageForHandler);\n            if (handler) handler.handler(sprite);\n        }\n\n        if (tileState.flag === 0 && data.tiles.indexOf(tileState) !== -1) {\n            data.tiles.removeElement(tileState);\n        }\n    }\n\n    function updateTileState(tileState: TileState, sprite: Sprite, tileIndexToMatch: number, map: tiles.TileMap) {\n        const tileWidth = 1 << map.scale;\n\n        const spriteL = sprite.left;\n        const spriteT = sprite.top;\n        const spriteR = sprite.right;\n        const spriteB = sprite.bottom;\n\n        const x0 = Math.idiv(spriteL, tileWidth);\n        const y0 = Math.idiv(spriteT, tileWidth);\n        const x1 = Math.idiv(spriteR, tileWidth);\n        const y1 = Math.idiv(spriteB, tileWidth);\n\n        tileState.flag = 0;\n\n        if (x0 === x1 && y0 === y1) {\n            if (x0 >= 0 && x0 < map.areaWidth() && y0 >= 0 && y0 < map.areaHeight()) {\n                const currentTile = map.getTile(x0, y0);\n                if (currentTile && currentTile.tileSet === tileIndexToMatch) {\n                    tileState.flag = TileFlag.Overlapping | TileFlag.FullyWithin | TileFlag.WithinArea;\n                }\n            }\n            return;\n        }\n\n        let isOverlappingTargetTile = false;\n        let isSpriteFullyContainedInTargetTiles = true;\n\n        for (let x = x0; x <= x1; x++) {\n            for (let y = y0; y <= y1; y++) {\n                if (x < 0 || x >= map.areaWidth() || y < 0 || y >= map.areaHeight()) {\n                    isSpriteFullyContainedInTargetTiles = false;\n                    continue;\n                }\n\n                const currentTile = map.getTile(x, y);\n                if (currentTile && currentTile.tileSet === tileIndexToMatch) {\n                    isOverlappingTargetTile = true;\n                } else {\n                    isSpriteFullyContainedInTargetTiles = false;\n                }\n            }\n        }\n\n        if (isOverlappingTargetTile) {\n            tileState.flag |= TileFlag.Overlapping;\n            if (isSpriteFullyContainedInTargetTiles) {\n                tileState.flag |= TileFlag.WithinArea;\n            }\n        }\n    }\n\n    /**\n     * Checks if a sprite is currently overlapping any tile with the specified image.\n     * This is a synchronous check performed at the moment the block is called.\n     * @param sprite The sprite to check.\n     * @param tileImage The image of the tile to check for overlap with.\n     * @returns true if the sprite is overlapping a tile with the given image, false otherwise.\n     */\n    //% blockId=\"events_is_sprite_overlapping_tile_image\"\n    //% block=\"$sprite is currently overlapping tile image $tileImage\"\n    //% sprite.defl=mySprite\n    //% tileImage.shadow=tileset_tile_picker\n    //% group=\"Tilemaps\"\n    //% weight=95\n    export function isSpriteOverlappingTileImage(sprite: Sprite, tileImage: Image): boolean {\n        if (!sprite || !tileImage) {\n            return false;\n        }\n\n        const scene = game.currentScene();\n        const tm = scene.tileMap;\n\n        if (!tm || tm.areaWidth() === 0 || tm.areaHeight() === 0) {\n            return false;\n        }\n\n        const scale = 1 << tm.scale;\n\n        const spriteL = sprite.left;\n        const spriteR = sprite.right;\n        const spriteT = sprite.top;\n        const spriteB = sprite.bottom;\n\n        const minCol = Math.max(0, Math.floor(spriteL / scale));\n        const maxCol = Math.min(tm.areaWidth() - 1, Math.floor(spriteR / scale));\n        const minRow = Math.max(0, Math.floor(spriteT / scale));\n        const maxRow = Math.min(tm.areaHeight() - 1, Math.floor(spriteB / scale));\n\n        for (let r = minRow; r <= maxRow; r++) {\n            for (let c = minCol; c <= maxCol; c++) {\n                const tileObject = tm.getTile(c, r);\n\n                if (tileObject && tileObject.tileSet !== undefined) {\n                    const tileId = tileObject.tileSet;\n                    const currentTileImgFromMap = tm.getTileImage(tileId);\n\n                    if (currentTileImgFromMap && currentTileImgFromMap.equals(tileImage)) {\n                        const tileLeft = c * scale;\n                        const tileTop = r * scale;\n                        const tileRight = tileLeft + scale;\n                        const tileBottom = tileTop + scale;\n\n                        if (spriteL < tileRight &&\n                            spriteR > tileLeft &&\n                            spriteT < tileBottom &&\n                            spriteB > tileTop) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"better overlaps\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1745518931407,"editorVersion":"2.0.53","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"//% block=\"Better Overlaps\"\n//% color=\"#FB8C00\" icon=\"\\uf259\"\n//% groups=\"['Sprites','Tilemaps']\"\nnamespace events {\n    export const SPRITE_DATA_KEY = \"@$_events_sprite_data\";\n\n    export enum SpriteEvent {\n        //% block=\"starts overlapping\"\n        StartOverlapping,\n        //% block=\"stops overlapping\"\n        StopOverlapping\n    }\n\n    export enum TileEvent {\n        //% block=\"starts overlapping\"\n        StartOverlapping,\n        //% block=\"stops overlapping\"\n        StopOverlapping,\n        //% block=\"fully within\"\n        Enters,\n        //% block=\"no longer fully within\"\n        Exits,\n        //% block=\"fully within area covered by\"\n        EntersArea,\n        //% block=\"no longer fully within area covered by\"\n        ExitsArea\n    }\n\n    // REMOVED Enums: RegionEvent, WallEvent, WallFlag\n\n    enum TileFlag { // Kept from original\n        Overlapping = 1 << 0,\n        FullyWithin = 1 << 1,\n        WithinArea = 1 << 2\n    }\n\n    type SpriteHandler = (sprite: Sprite, otherSprite: Sprite) => void; // Kept\n    type TileHandler = (sprite: Sprite) => void; // Kept\n\n    let stateStack: EventState[]; // Kept\n\n    // REMOVED Classes: Region, WallCondition, Coordinate\n\n    class EventState { // Kept, but modified\n        spriteHandlers: SpriteHandlerEntry[];\n        tileHandlers: TileHandlerEntry[];\n        // REMOVED: regionHandlers: RegionHandlerEntry[];\n        // REMOVED: wallHandlers: WallHandlerEntry[];\n        trackedSprites: Sprite[];\n\n        constructor() {\n            this.spriteHandlers = [];\n            this.tileHandlers = [];\n            // REMOVED: this.regionHandlers = [];\n            // REMOVED: this.wallHandlers = [];\n            this.trackedSprites = [];\n\n            game.eventContext().registerFrameHandler(scene.PHYSICS_PRIORITY + 1, () => {\n                this.update();\n            });\n        }\n\n        update() {\n            // REMOVED: let shouldPruneCurrentState: boolean; from original wall logic\n            // REMOVED: let shouldPruneAllStates: boolean; from original wall logic\n\n            for (const sprite of this.trackedSprites) {\n                if (!sprite || sprite.flags & sprites.Flag.Destroyed) continue;\n                const data = sprite.data[SPRITE_DATA_KEY] as SpriteEventData;\n                if (!data) continue;\n\n                // Sprite-Sprite overlap logic (Kept from original)\n                // Iterate backwards if removing elements, or filter. Original used removeElement.\n                // For simplicity and closer match to original's intent (though removeElement in loop can be tricky):\n                let i = 0;\n                while (i < data.overlappingSprites.length) {\n                    const otherSprite = data.overlappingSprites[i];\n                    if (!otherSprite || otherSprite.flags & sprites.Flag.Destroyed || !sprite.overlapsWith(otherSprite)) {\n                        data.overlappingSprites.removeElement(otherSprite); // Original method\n                        // If element removed, do not increment i, so next element is at current i\n                        if (!otherSprite || otherSprite.flags & sprites.Flag.Destroyed) continue;\n\n                        const handler = this.getSpriteHandler(SpriteEvent.StopOverlapping, sprite.kind(), otherSprite.kind());\n                        if (handler) handler.handler(sprite, otherSprite);\n                    } else {\n                        i++;\n                    }\n                }\n\n                // Tile overlap logic (Kept from original)\n                const tileMapRef = game.currentScene().tileMap;\n                if (tileMapRef) {\n                    for (const handler of this.tileHandlers) {\n                        if (handler.kind === sprite.kind() && handler.tile) { // Ensure handler.tile exists\n                            const tileIndex = tileMapRef.getImageType(handler.tile); // Get TILE INDEX from Image\n                            if (tileIndex !== -1) { // -1 if image not in palette\n                                updateTileStateAndFireEvents(\n                                    sprite,\n                                    tileIndex, // Pass TILE INDEX\n                                    tileMapRef\n                                );\n                            }\n                        }\n                    }\n                }\n                // REMOVED: Wall processing logic from original's update()\n            }\n\n            // REMOVED: this.doRegionUpdate(); (from original)\n\n            this.pruneTrackedSprites();\n        }\n\n        getSpriteHandler(event: SpriteEvent, kind: number, otherKind: number) { // Kept from original\n            for (const handler of this.spriteHandlers) {\n                if (handler.event === event && handler.kind === kind && handler.otherKind === otherKind)\n                    return handler;\n            }\n            return undefined;\n        }\n\n        getTileHandler(event: TileEvent, kind: number, image: Image) { // Kept from original\n            for (const handler of this.tileHandlers) {\n                if (handler.event === event && handler.kind === kind && handler.tile && handler.tile.equals(image)) // Added null check for handler.tile\n                    return handler;\n            }\n            return undefined;\n        }\n\n        // REMOVED: getRegionHandler (from original)\n        // REMOVED: getWallHandler (from original)\n\n        protected pruneTrackedSprites() { // Kept from original, iterate backwards for safe removal\n            for (let i = this.trackedSprites.length - 1; i >= 0; i--) {\n                const sprite = this.trackedSprites[i];\n                if (!sprite || sprite.flags & sprites.Flag.Destroyed) {\n                    this.trackedSprites.removeAt(i);\n                }\n            }\n        }\n\n        // REMOVED: doRegionUpdate (from original)\n        // REMOVED: runRegionHandler (from original)\n    }\n\n    // REMOVED: wallTileStateIsHitting (from original)\n    // REMOVED: wallStateIsHitting (from original)\n\n    class SpriteHandlerEntry { // Kept from original\n        constructor(\n            public event: SpriteEvent,\n            public kind: number,\n            public otherKind: number,\n            public handler: SpriteHandler\n        ) { }\n    }\n\n    class TileHandlerEntry { // Kept from original\n        constructor(\n            public event: TileEvent,\n            public kind: number,\n            public tile: Image, // This is the target Image for this handler\n            public handler: TileHandler\n        ) { }\n    }\n\n    // REMOVED: RegionHandlerEntry (from original)\n    // REMOVED: WallHandlerEntry (from original)\n\n    class SpriteEventData { // Kept from original, but modified\n        overlappingSprites: Sprite[];\n        tiles: TileState[]; // Stores state by TILE INDEX\n        // REMOVED: regions: RegionState[];\n        // REMOVED: walls: WallState[];\n\n        constructor(public owner: Sprite) {\n            this.overlappingSprites = [];\n            this.tiles = [];\n            // REMOVED: this.regions = [];\n            // REMOVED: this.walls = [];\n        }\n\n        getTileEntry(tileIndex: number, createIfMissing = false) { // 'tileIndex' is the ID\n            for (const ts of this.tiles) { // Renamed loop var to avoid conflict\n                if (ts.tileIndex === tileIndex) { // Compare with renamed tileIndex property\n                    return ts;\n                }\n            }\n            if (createIfMissing) {\n                const newEntry = new TileState(tileIndex); // Use renamed tileIndex property\n                this.tiles.push(newEntry);\n                return newEntry;\n            }\n            return undefined;\n        }\n\n        // REMOVED: getRegionEntry (from original)\n        // REMOVED: getWallEntry (from original)\n    }\n\n    class TileState { // MODIFIED: 'tile' property renamed to 'tileIndex' for clarity\n        flag: number;\n        constructor(public tileIndex: number, flag = 0) { // 'tileIndex' stores the TILE INDEX (ID)\n            this.flag = flag;\n        }\n    }\n\n    // REMOVED: RegionState (from original)\n    // REMOVED: WallState (from original)\n    // REMOVED: WallTileState (from original)\n\n    function init() { // Kept from original\n        if (stateStack) return;\n        stateStack = [new EventState()];\n\n        game.addScenePushHandler(() => {\n            stateStack.push(new EventState());\n        });\n\n        game.addScenePopHandler(() => { // MODIFIED: Corrected from original's removeScenePushHandler\n            if (stateStack.length > 1) {\n                stateStack.pop();\n            }\n            if (!stateStack.length) {\n                stateStack.push(new EventState()); // Re-initialize if stack became empty (original behavior)\n            }\n        });\n    }\n\n    function state() { // Kept from original\n        init();\n        return stateStack[stateStack.length - 1];\n    }\n\n    //% blockId=sprite_event_ext_sprite_event // Kept original blockId\n    //% block=\"on $sprite of kind $kind $event with $otherSprite of kind $otherKind\"\n    //% draggableParameters=\"reporter\" // KEPT from original\n    //% kind.shadow=spritekind\n    //% otherKind.shadow=spritekind\n    //% weight=90\n    //% group=\"Sprites\" \n    export function spriteEvent(kind: number, otherKind: number, event: SpriteEvent, handler: (sprite: Sprite, otherSprite: Sprite) => void) { // Kept from original\n        init();\n\n        const existing = state().getSpriteHandler(event, kind, otherKind);\n        if (existing) {\n            existing.handler = handler;\n            return;\n        }\n\n        state().spriteHandlers.push(\n            new SpriteHandlerEntry(event, kind, otherKind, handler)\n        );\n\n        sprites.onOverlap(kind, otherKind, (sprite, otherSprite) => {\n            const currentState = state();\n            if (!sprite || !otherSprite || sprite.flags & sprites.Flag.Destroyed || otherSprite.flags & sprites.Flag.Destroyed) return;\n\n            if (!sprite.data[SPRITE_DATA_KEY]) {\n                sprite.data[SPRITE_DATA_KEY] = new SpriteEventData(sprite);\n                if (currentState.trackedSprites.indexOf(sprite) === -1) {\n                    currentState.trackedSprites.push(sprite);\n                }\n            }\n\n            const data: SpriteEventData = sprite.data[SPRITE_DATA_KEY];\n            if (!data) return;\n            const isOverlappingAlready = data.overlappingSprites.indexOf(otherSprite) !== -1;\n\n            if (!isOverlappingAlready) {\n                data.overlappingSprites.push(otherSprite);\n\n                const handler = currentState.getSpriteHandler(SpriteEvent.StartOverlapping, kind, otherKind);\n                if (handler) {\n                    handler.handler(sprite, otherSprite);\n                }\n            }\n        });\n    }\n\n    //% blockId=sprite_event_ext_tile_event // Kept original blockId\n    //% block=\"on $sprite of kind $kind $event tile $tile\"\n    //% draggableParameters=\"reporter\" // KEPT from original\n    //% kind.shadow=spritekind\n    //% tile.shadow=tileset_tile_picker\n    //% weight=100\n    //% group=\"Tilemaps\" \n    export function tileEvent(kind: number, tile: Image, event: TileEvent, handler: (sprite: Sprite) => void) { // Kept from original\n        init();\n        if (!tile) return;\n\n        const existing = state().getTileHandler(event, kind, tile);\n        if (existing) {\n            existing.handler = handler;\n            return;\n        }\n\n        state().tileHandlers.push(\n            new TileHandlerEntry(event, kind, tile, handler)\n        );\n\n        scene.onOverlapTile(kind, tile, (sprite, location) => {\n            if (!sprite || !location) return;\n            const tileMapInstance = game.currentScene().tileMap;\n            if (!tileMapInstance) return;\n\n            // 'location.tileSet' is the index of the actual tile instance that was overlapped.\n            // We need to ensure this event triggers our logic for the *specific image* 'tile'\n            // that this handler was registered for. scene.onOverlapTile(kind, tile, ...) already does this matching.\n            // So, location.tileSet will be the index of an instance of 'tile'.\n            updateTileStateAndFireEvents(sprite, location.tileSet, tileMapInstance);\n        });\n    }\n\n    function updateTileStateAndFireEvents(sprite: Sprite, tileIndex: number, map: tiles.TileMap) { // Kept from original, tileIndex is ID\n        if (!sprite || !map) return;\n        let data: SpriteEventData = sprite.data[SPRITE_DATA_KEY];\n\n        if (!data) {\n            data = new SpriteEventData(sprite);\n            sprite.data[SPRITE_DATA_KEY] = data;\n            if (state().trackedSprites.indexOf(sprite) === -1) {\n                state().trackedSprites.push(sprite);\n            }\n        }\n\n        const tileState = data.getTileEntry(tileIndex, true);\n\n        const oldFlags = tileState.flag;\n        updateTileState(tileState, sprite, tileIndex, map);\n\n        if (oldFlags === tileState.flag) return;\n\n        // Call runTileEventHandlers for each relevant event type\n        // This simplified dispatch was in original, restoring it.\n        // Original called runTileEventHandlers without checking flags first inside this func.\n        // The runTileEventHandlers itself will check based on event type and flags.\n        if (tileState.flag & TileFlag.Overlapping) {\n            if (!(oldFlags & TileFlag.Overlapping)) {\n                runTileEventHandlers(sprite, TileEvent.StartOverlapping, tileIndex);\n            }\n        }\n        else if (oldFlags & TileFlag.Overlapping) {\n            runTileEventHandlers(sprite, TileEvent.StopOverlapping, tileIndex);\n        }\n\n        if (tileState.flag & TileFlag.FullyWithin) {\n            if (!(oldFlags & TileFlag.FullyWithin)) {\n                runTileEventHandlers(sprite, TileEvent.Enters, tileIndex);\n            }\n        }\n        else if (oldFlags & TileFlag.FullyWithin) {\n            runTileEventHandlers(sprite, TileEvent.Exits, tileIndex);\n        }\n\n        if (tileState.flag & TileFlag.WithinArea) {\n            if (!(oldFlags & TileFlag.WithinArea)) {\n                runTileEventHandlers(sprite, TileEvent.EntersArea, tileIndex);\n            }\n        }\n        else if (oldFlags & TileFlag.WithinArea) {\n            runTileEventHandlers(sprite, TileEvent.ExitsArea, tileIndex);\n        }\n\n\n        if (tileState.flag === 0 && data.tiles.indexOf(tileState) !== -1) {\n            data.tiles.removeElement(tileState);\n        }\n    }\n\n    function updateTileState(tileState: TileState, sprite: Sprite, tileIndexToMatch: number, map: tiles.TileMap): TileState { // Kept original signature (returns TileState)\n        const tileWidth = 1 << map.scale;\n\n        const spriteL = sprite.left;\n        const spriteT = sprite.top;\n        const spriteR = sprite.right;\n        const spriteB = sprite.bottom;\n\n        const x0 = Math.idiv(spriteL, tileWidth);\n        const y0 = Math.idiv(spriteT, tileWidth);\n        const x1 = Math.idiv(spriteR, tileWidth);\n        const y1 = Math.idiv(spriteB, tileWidth);\n\n        tileState.flag = 0;\n\n        if (x0 === x1 && y0 === y1) {\n            if (x0 >= 0 && x0 < map.areaWidth() && y0 >= 0 && y0 < map.areaHeight()) { // Bounds check\n                // Original used map.getTileIndex(x0, y0)\n                const currentTile = map.getTile(x0, y0);\n                if (currentTile && currentTile.tileSet === tileIndexToMatch) {\n                    tileState.flag = TileFlag.Overlapping | TileFlag.FullyWithin | TileFlag.WithinArea;\n                }\n            }\n            return tileState; // Original returns tileState\n        }\n\n        // Original logic for multi-cell overlap:\n        // It sets Overlapping if any matching tile is found.\n        // It then *returns early* if a non-matching tile is found *after* an overlapping one was already found.\n        // This implies WithinArea should only be true if ALL tiles under the sprite are the target tile.\n\n        let allTilesMatch = true; // Assume all tiles under sprite will match target\n        for (let x = x0; x <= x1; x++) {\n            for (let y = y0; y <= y1; y++) {\n                if (x < 0 || x >= map.areaWidth() || y < 0 || y >= map.areaHeight()) { // Bounds check\n                    allTilesMatch = false; // Part of sprite is off-map, so not all matching\n                    continue;\n                }\n                const currentTile = map.getTile(x, y); // Original used map.getTileIndex(x,y)\n                if (currentTile && currentTile.tileSet === tileIndexToMatch) {\n                    tileState.flag |= TileFlag.Overlapping; // Set overlapping if any part matches\n                } else {\n                    allTilesMatch = false; // Found a non-matching tile under the sprite\n                }\n            }\n        }\n\n        if ((tileState.flag & TileFlag.Overlapping) && allTilesMatch) {\n            tileState.flag |= TileFlag.WithinArea;\n        }\n        // Note: TileFlag.FullyWithin is only set if sprite fits in a single cell of the target type (handled above).\n\n        return tileState; // Original returns tileState\n    }\n\n    // Kept runTileEventHandlers from original structure.\n    // This function dispatches the event based on what's passed in.\n    // In the original, updateTileStateAndFireEvents calls this multiple times.\n    function runTileEventHandlers(sprite: Sprite, event: TileEvent, tileIndex: number) {\n        const tileMap = game.currentScene().tileMap;\n        if (!tileMap) return;\n        const image = tileMap.getTileImage(tileIndex); // Get image from index\n        if (!image) return;\n\n        const handler = state().getTileHandler(\n            event,\n            sprite.kind(),\n            image // Use the actual image for handler lookup\n        );\n        if (handler) handler.handler(sprite);\n    }\n\n    // REMOVED: All Wall and Region block functions and their helpers from original\n\n    /**\n     * ADDED BLOCK\n     * Checks if a sprite is currently overlapping any tile with the specified image.\n     * This is a synchronous check performed at the moment the block is called.\n     * @param sprite The sprite to check.\n     * @param tileImage The image of the tile to check for overlap with.\n     * @returns true if the sprite is overlapping a tile with the given image, false otherwise.\n     */\n    //% blockId=\"better_overlaps_is_sprite_overlapping_tile_image\" // Using a new unique blockId\n    //% block=\"$sprite is currently overlapping tile image $tileImage\"\n    //% sprite.defl=mySprite\n    //% tileImage.shadow=tileset_tile_picker\n    //% group=\"Tilemaps\" \n    //% weight=95\n    export function isSpriteOverlappingTileImage(sprite: Sprite, tileImage: Image): boolean {\n        if (!sprite || !tileImage) {\n            return false;\n        }\n\n        const scene = game.currentScene();\n        const tm = scene.tileMap;\n\n        if (!tm || tm.areaWidth() === 0 || tm.areaHeight() === 0) {\n            return false;\n        }\n\n        const scale = 1 << tm.scale;\n\n        const spriteL = sprite.left;\n        const spriteR = sprite.right;\n        const spriteT = sprite.top;\n        const spriteB = sprite.bottom;\n\n        const minCol = Math.max(0, Math.floor(spriteL / scale));\n        const maxCol = Math.min(tm.areaWidth() - 1, Math.floor(spriteR / scale));\n        const minRow = Math.max(0, Math.floor(spriteT / scale));\n        const maxRow = Math.min(tm.areaHeight() - 1, Math.floor(spriteB / scale));\n\n        for (let r = minRow; r <= maxRow; r++) {\n            for (let c = minCol; c <= maxCol; c++) {\n                const tileObject = tm.getTile(c, r);\n\n                if (tileObject && tileObject.tileSet !== undefined) {\n                    const tileId = tileObject.tileSet;\n                    const currentTileImgFromMap = tm.getTileImage(tileId);\n\n                    if (currentTileImgFromMap && currentTileImgFromMap.equals(tileImage)) {\n                        const tileLeft = c * scale;\n                        const tileTop = r * scale;\n                        const tileRight = tileLeft + scale;\n                        const tileBottom = tileTop + scale;\n\n                        if (spriteL < tileRight &&\n                            spriteR > tileLeft &&\n                            spriteT < tileBottom &&\n                            spriteB > tileTop) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"better overlaps\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1745521348105,"editorVersion":"2.0.53","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"//% block=\"Better Overlaps\"\n//% color=\"#FB8C00\" icon=\"\\uf259\"\n//% groups=\"['Overlaps']\"\nnamespace overlaps {\n    export const SPRITE_DATA_KEY = \"@$_events_sprite_data\";\n\n    export enum SpriteEvent {\n        //% block=\"starts overlapping\"\n        StartOverlapping,\n        //% block=\"stops overlapping\"\n        StopOverlapping\n    }\n\n    export enum TileEvent {\n        //% block=\"starts overlapping\"\n        StartOverlapping,\n        //% block=\"stops overlapping\"\n        StopOverlapping,\n        //% block=\"fully within\"\n        Enters,\n        //% block=\"no longer fully within\"\n        Exits,\n        //% block=\"fully within area covered by\"\n        EntersArea,\n        //% block=\"no longer fully within area covered by\"\n        ExitsArea\n    }\n\n    enum TileFlag {\n        Overlapping = 1 << 0,\n        FullyWithin = 1 << 1,\n        WithinArea = 1 << 2\n    }\n\n    type SpriteHandler = (sprite: Sprite, otherSprite: Sprite) => void;\n    type TileHandler = (sprite: Sprite) => void;\n\n    let stateStack: EventState[];\n\n    class EventState {\n        spriteHandlers: SpriteHandlerEntry[];\n        tileHandlers: TileHandlerEntry[];\n        trackedSprites: Sprite[];\n\n        constructor() {\n            this.spriteHandlers = [];\n            this.tileHandlers = [];\n            this.trackedSprites = [];\n\n            game.eventContext().registerFrameHandler(scene.PHYSICS_PRIORITY + 1, () => {\n                this.update();\n            });\n        }\n\n        update() {\n            for (const sprite of this.trackedSprites) {\n                if (!sprite || sprite.flags & sprites.Flag.Destroyed) continue;\n\n                const data = sprite.data[SPRITE_DATA_KEY] as SpriteEventData;\n                if (!data) continue;\n\n                for (let i = data.overlappingSprites.length - 1; i >= 0; i--) {\n                    const otherSprite = data.overlappingSprites[i];\n                    if (!otherSprite || otherSprite.flags & sprites.Flag.Destroyed || !sprite.overlapsWith(otherSprite)) {\n                        data.overlappingSprites.removeElement(otherSprite);\n                        if (!otherSprite || otherSprite.flags & sprites.Flag.Destroyed) continue;\n\n                        const handler = this.getSpriteHandler(SpriteEvent.StopOverlapping, sprite.kind(), otherSprite.kind());\n                        if (handler) handler.handler(sprite, otherSprite);\n                    }\n                }\n\n                const tileMap = game.currentScene().tileMap;\n                if (tileMap) {\n                    for (const handler of this.tileHandlers) {\n                        if (handler.kind === sprite.kind()) {\n                            const targetTileIndex = tileMap.getImageType(handler.tile);\n                            if (targetTileIndex !== -1) {\n                                updateTileStateAndFireEvents(\n                                    sprite,\n                                    targetTileIndex,\n                                    tileMap\n                                );\n                            }\n                        }\n                    }\n                }\n            }\n            this.pruneTrackedSprites();\n        }\n\n        getSpriteHandler(event: SpriteEvent, kind: number, otherKind: number) {\n            for (const handler of this.spriteHandlers) {\n                if (handler.event === event && handler.kind === kind && handler.otherKind === otherKind)\n                    return handler;\n            }\n            return undefined;\n        }\n\n        getTileHandler(event: TileEvent, kind: number, image: Image) {\n            for (const handler of this.tileHandlers) {\n                if (handler.event === event && handler.kind === kind && handler.tile && handler.tile.equals(image))\n                    return handler;\n            }\n            return undefined;\n        }\n\n        protected pruneTrackedSprites() {\n            for (let i = this.trackedSprites.length - 1; i >= 0; i--) {\n                const sprite = this.trackedSprites[i];\n                if (!sprite || sprite.flags & sprites.Flag.Destroyed) {\n                    this.trackedSprites.removeAt(i);\n                }\n            }\n        }\n    }\n\n    class SpriteHandlerEntry {\n        constructor(\n            public event: SpriteEvent,\n            public kind: number,\n            public otherKind: number,\n            public handler: SpriteHandler\n        ) { }\n    }\n\n    class TileHandlerEntry {\n        constructor(\n            public event: TileEvent,\n            public kind: number,\n            public tile: Image,\n            public handler: TileHandler\n        ) { }\n    }\n\n    class SpriteEventData {\n        overlappingSprites: Sprite[];\n        tiles: TileState[];\n\n        constructor(public owner: Sprite) {\n            this.overlappingSprites = [];\n            this.tiles = [];\n        }\n\n        getTileEntry(tileIndex: number, createIfMissing = false) {\n            for (const tile of this.tiles) {\n                if (tile.tileIndex === tileIndex) {\n                    return tile;\n                }\n            }\n\n            if (createIfMissing) {\n                const newEntry = new TileState(tileIndex);\n                this.tiles.push(newEntry)\n                return newEntry;\n            }\n            return undefined;\n        }\n    }\n\n    class TileState {\n        flag: number;\n        constructor(public tileIndex: number, flag = 0) {\n            this.flag = flag;\n        }\n    }\n\n    function init() {\n        if (stateStack) return;\n        stateStack = [new EventState()];\n\n        game.addScenePushHandler(() => {\n            stateStack.push(new EventState());\n        });\n\n        game.addScenePopHandler(() => {\n            if (stateStack.length > 1) {\n                stateStack.pop();\n            }\n            if (stateStack.length === 0) {\n                stateStack.push(new EventState());\n            }\n        });\n    }\n\n    function state() {\n        init();\n        return stateStack[stateStack.length - 1];\n    }\n\n    //% blockId=sprite_overlap_sprite_event\n    //% block=\"on $sprite of kind $kind $event with $otherSprite of kind $otherKind\"\n    //% draggableParameters=\"reporter\"\n    //% kind.shadow=spritekind\n    //% otherKind.shadow=spritekind\n    //% weight=90\n    //% group=\"Overlaps\"\n    export function spriteEvent(kind: number, otherKind: number, event: SpriteEvent, handler: (sprite: Sprite, otherSprite: Sprite) => void) {\n        init();\n\n        const existing = state().getSpriteHandler(event, kind, otherKind);\n        if (existing) {\n            existing.handler = handler;\n            return;\n        }\n\n        state().spriteHandlers.push(\n            new SpriteHandlerEntry(event, kind, otherKind, handler)\n        );\n\n        sprites.onOverlap(kind, otherKind, (sprite, otherSprite) => {\n            const currentState = state();\n            if (!sprite || !otherSprite || sprite.flags & sprites.Flag.Destroyed || otherSprite.flags & sprites.Flag.Destroyed) return;\n\n            if (!sprite.data[SPRITE_DATA_KEY]) {\n                sprite.data[SPRITE_DATA_KEY] = new SpriteEventData(sprite);\n                if (currentState.trackedSprites.indexOf(sprite) === -1) {\n                    currentState.trackedSprites.push(sprite);\n                }\n            }\n\n            const data: SpriteEventData = sprite.data[SPRITE_DATA_KEY];\n            if (!data) return;\n            const isOverlappingAlready = data.overlappingSprites.indexOf(otherSprite) !== -1;\n\n            if (!isOverlappingAlready) {\n                data.overlappingSprites.push(otherSprite);\n\n                const handler = currentState.getSpriteHandler(SpriteEvent.StartOverlapping, kind, otherKind)\n                if (handler) {\n                    handler.handler(sprite, otherSprite);\n                }\n            }\n        });\n    }\n\n    //% blockId=sprite_overlap_tile_event\n    //% block=\"on $sprite of kind $kind $event tile $tile\"\n    //% draggableParameters=\"reporter\"\n    //% kind.shadow=spritekind\n    //% tile.shadow=tileset_tile_picker\n    //% weight=100\n    //% group=\"Overlaps\"\n    export function tileEvent(kind: number, tile: Image, event: TileEvent, handler: (sprite: Sprite) => void) {\n        init();\n        if (!tile) return;\n\n        const existing = state().getTileHandler(event, kind, tile);\n        if (existing) {\n            existing.handler = handler;\n            return;\n        }\n\n        state().tileHandlers.push(\n            new TileHandlerEntry(event, kind, tile, handler)\n        );\n\n        scene.onOverlapTile(kind, tile, (sprite, location) => {\n            if (!sprite || !location) return;\n            const tileMapInstance = game.currentScene().tileMap;\n            if (!tileMapInstance) return;\n\n            const tileIndex = tileMapInstance.getImageType(tile);\n\n            if (tileIndex !== -1) {\n                updateTileStateAndFireEvents(sprite, tileIndex, tileMapInstance);\n            }\n        });\n    }\n\n    function updateTileStateAndFireEvents(sprite: Sprite, tileIndex: number, map: tiles.TileMap) {\n        if (!sprite || !map) return;\n        let data: SpriteEventData = sprite.data[SPRITE_DATA_KEY];\n\n        if (!data) {\n            data = new SpriteEventData(sprite);\n            sprite.data[SPRITE_DATA_KEY] = data;\n            if (state().trackedSprites.indexOf(sprite) === -1) {\n                state().trackedSprites.push(sprite);\n            }\n        }\n\n        const tileState = data.getTileEntry(tileIndex, true);\n        const oldFlags = tileState.flag;\n        updateTileState(tileState, sprite, tileIndex, map);\n\n        if (oldFlags === tileState.flag) return;\n\n        const tileImageForHandler = map.getTileImage(tileIndex);\n        if (!tileImageForHandler) return;\n\n        const currentState = state();\n\n        if (tileState.flag & TileFlag.Overlapping) {\n            if (!(oldFlags & TileFlag.Overlapping)) {\n                const handler = currentState.getTileHandler(TileEvent.StartOverlapping, sprite.kind(), tileImageForHandler);\n                if (handler) handler.handler(sprite);\n            }\n        } else if (oldFlags & TileFlag.Overlapping) {\n            const handler = currentState.getTileHandler(TileEvent.StopOverlapping, sprite.kind(), tileImageForHandler);\n            if (handler) handler.handler(sprite);\n        }\n\n        if (tileState.flag & TileFlag.FullyWithin) {\n            if (!(oldFlags & TileFlag.FullyWithin)) {\n                const handler = currentState.getTileHandler(TileEvent.Enters, sprite.kind(), tileImageForHandler);\n                if (handler) handler.handler(sprite);\n            }\n        } else if (oldFlags & TileFlag.FullyWithin) {\n            const handler = currentState.getTileHandler(TileEvent.Exits, sprite.kind(), tileImageForHandler);\n            if (handler) handler.handler(sprite);\n        }\n\n        if (tileState.flag & TileFlag.WithinArea) {\n            if (!(oldFlags & TileFlag.WithinArea)) {\n                const handler = currentState.getTileHandler(TileEvent.EntersArea, sprite.kind(), tileImageForHandler);\n                if (handler) handler.handler(sprite);\n            }\n        } else if (oldFlags & TileFlag.WithinArea) {\n            const handler = currentState.getTileHandler(TileEvent.ExitsArea, sprite.kind(), tileImageForHandler);\n            if (handler) handler.handler(sprite);\n        }\n\n        if (tileState.flag === 0 && data.tiles.indexOf(tileState) !== -1) {\n            data.tiles.removeElement(tileState);\n        }\n    }\n\n    function updateTileState(tileState: TileState, sprite: Sprite, tileIndexToMatch: number, map: tiles.TileMap) {\n        const tileWidth = 1 << map.scale;\n\n        const spriteL = sprite.left;\n        const spriteT = sprite.top;\n        const spriteR = sprite.right;\n        const spriteB = sprite.bottom;\n\n        const x0 = Math.idiv(spriteL, tileWidth);\n        const y0 = Math.idiv(spriteT, tileWidth);\n        const x1 = Math.idiv(spriteR, tileWidth);\n        const y1 = Math.idiv(spriteB, tileWidth);\n\n        tileState.flag = 0;\n\n        if (x0 === x1 && y0 === y1) {\n            if (x0 >= 0 && x0 < map.areaWidth() && y0 >= 0 && y0 < map.areaHeight()) {\n                const currentTile = map.getTile(x0, y0);\n                if (currentTile && currentTile.tileSet === tileIndexToMatch) {\n                    tileState.flag = TileFlag.Overlapping | TileFlag.FullyWithin | TileFlag.WithinArea;\n                }\n            }\n            return;\n        }\n\n        let isOverlappingTargetTile = false;\n        let isSpriteFullyContainedInTargetTiles = true;\n\n        for (let x = x0; x <= x1; x++) {\n            for (let y = y0; y <= y1; y++) {\n                if (x < 0 || x >= map.areaWidth() || y < 0 || y >= map.areaHeight()) {\n                    isSpriteFullyContainedInTargetTiles = false;\n                    continue;\n                }\n\n                const currentTile = map.getTile(x, y);\n                if (currentTile && currentTile.tileSet === tileIndexToMatch) {\n                    isOverlappingTargetTile = true;\n                } else {\n                    isSpriteFullyContainedInTargetTiles = false;\n                }\n            }\n        }\n\n        if (isOverlappingTargetTile) {\n            tileState.flag |= TileFlag.Overlapping;\n            if (isSpriteFullyContainedInTargetTiles) {\n                tileState.flag |= TileFlag.WithinArea;\n            }\n        }\n    }\n\n    /**\n     * Checks if a sprite is currently overlapping any tile with the specified image.\n     * This is a synchronous check performed at the moment the block is called.\n     * @param sprite The sprite to check.\n     * @param tileImage The image of the tile to check for overlap with.\n     * @returns true if the sprite is overlapping a tile with the given image, false otherwise.\n     */\n    //% blockId=sprite_overlap_tile_bool\n    //% block=\"$sprite is currently overlapping tile image $tileImage\"\n    //% sprite.defl=mySprite\n    //% tileImage.shadow=tileset_tile_picker\n    //% weight=95\n    //% group=\"Overlaps\"\n    export function isSpriteOverlappingTileImage(sprite: Sprite, tileImage: Image): boolean {\n        if (!sprite || !tileImage) {\n            return false;\n        }\n\n        const scene = game.currentScene();\n        const tm = scene.tileMap;\n\n        if (!tm || tm.areaWidth() === 0 || tm.areaHeight() === 0) {\n            return false;\n        }\n\n        const scale = 1 << tm.scale;\n\n        const spriteL = sprite.left;\n        const spriteR = sprite.right;\n        const spriteT = sprite.top;\n        const spriteB = sprite.bottom;\n\n        const minCol = Math.max(0, Math.floor(spriteL / scale));\n        const maxCol = Math.min(tm.areaWidth() - 1, Math.floor(spriteR / scale));\n        const minRow = Math.max(0, Math.floor(spriteT / scale));\n        const maxRow = Math.min(tm.areaHeight() - 1, Math.floor(spriteB / scale));\n\n        for (let r = minRow; r <= maxRow; r++) {\n            for (let c = minCol; c <= maxCol; c++) {\n                const tileObject = tm.getTile(c, r);\n\n                if (tileObject && tileObject.tileSet !== undefined) {\n                    const tileId = tileObject.tileSet;\n                    const currentTileImgFromMap = tm.getTileImage(tileId);\n\n                    if (currentTileImgFromMap && currentTileImgFromMap.equals(tileImage)) {\n                        const tileLeft = c * scale;\n                        const tileTop = r * scale;\n                        const tileRight = tileLeft + scale;\n                        const tileBottom = tileTop + scale;\n\n                        if (spriteL < tileRight &&\n                            spriteR > tileLeft &&\n                            spriteT < tileBottom &&\n                            spriteB > tileTop) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"better overlaps\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[{"id":"79678-09866-59894-48483","timestamp":1745516119454},{"id":"53281-14583-42209-46043","timestamp":1745516286179},{"id":"36394-87882-96627-03668","timestamp":1745516329209},{"id":"38172-43793-35867-39673","timestamp":1745516336279},{"id":"88289-32374-33567-41987","timestamp":1745516436990},{"id":"80319-23427-60536-27036","timestamp":1745516511016},{"id":"22852-02418-59724-97450","timestamp":1745516594295},{"id":"28905-39547-28090-18739","timestamp":1745516654512},{"id":"09885-39257-36477-63773","timestamp":1745516693925},{"id":"08272-34485-86366-92523","timestamp":1745516968608},{"id":"99521-42774-07779-55048","timestamp":1745517106299},{"id":"11423-84026-70276-16806","timestamp":1745517220369},{"id":"98847-65709-56880-42262","timestamp":1745517474307},{"id":"27467-58381-26491-90283","timestamp":1745517745336},{"id":"31228-29786-51260-74411","timestamp":1745518172979},{"id":"35994-87830-41796-06365","timestamp":1745518263928},{"id":"41986-46795-94520-29129","timestamp":1745518826050},{"id":"52510-48837-50636-84504","timestamp":1745518943722},{"id":"00297-53914-07570-58115","timestamp":1745521348345},{"id":"24959-11083-87622-94277","timestamp":1745521406473},{"id":"72796-28532-24509-48952","timestamp":1745521455456},{"id":"24014-57164-79837-77932","timestamp":1745522048358}],"lastSaveTime":1745522108092}